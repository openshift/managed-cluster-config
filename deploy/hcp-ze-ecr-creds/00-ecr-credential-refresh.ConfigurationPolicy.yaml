# ECR Credential Refresh for Zero-Egress HCP Clusters
#
# OHSS-49424: The global-pull-secret-syncer bug was backported to
# OCP 4.18+ where it overwrites kubelet ECR credentials.
# This CronJob refreshes additional-pull-secret every 4 hours
# so HCCO can merge it into global-pull-secret.
#
# The script auto-detects zero-egress clusters by checking for IDMS.
# Non-zero-egress clusters will exit early with success (no-op).
#
# Uses dynamic lookup to get the node-resolver image which is guaranteed
# to be cached on worker nodes and contains bash/oc.
#
# SOP: https://github.com/openshift/ops-sop/blob/master/hypershift/knowledge_base/howto/zero-egress-ecr-credential-refresh.md
# Tracking: OHSS-49424
apiVersion: policy.open-cluster-management.io/v1
kind: ConfigurationPolicy
metadata:
  name: hcp-ze-ecr-creds
spec:
  evaluationInterval:
    compliant: 2h
    noncompliant: 45s
  object-templates-raw: |
    - complianceType: mustonlyhave
      metadataComplianceType: musthave
      objectDefinition:
        apiVersion: v1
        kind: ServiceAccount
        metadata:
          name: ecr-credential-refresh
          namespace: kube-system
          labels:
            app: ecr-credential-refresh
            app.kubernetes.io/name: ecr-credential-refresh
            app.kubernetes.io/component: credential-management
    - complianceType: mustonlyhave
      metadataComplianceType: musthave
      objectDefinition:
        apiVersion: rbac.authorization.k8s.io/v1
        kind: Role
        metadata:
          name: ecr-credential-refresh
          namespace: kube-system
          labels:
            app: ecr-credential-refresh
        rules:
          - apiGroups: [""]
            resources: ["secrets"]
            resourceNames: ["additional-pull-secret"]
            verbs: ["get", "patch", "update"]
          - apiGroups: [""]
            resources: ["secrets"]
            verbs: ["create"]
    - complianceType: mustonlyhave
      metadataComplianceType: musthave
      objectDefinition:
        apiVersion: rbac.authorization.k8s.io/v1
        kind: RoleBinding
        metadata:
          name: ecr-credential-refresh
          namespace: kube-system
          labels:
            app: ecr-credential-refresh
        subjects:
          - kind: ServiceAccount
            name: ecr-credential-refresh
            namespace: kube-system
        roleRef:
          kind: Role
          name: ecr-credential-refresh
          apiGroup: rbac.authorization.k8s.io
    - complianceType: mustonlyhave
      metadataComplianceType: musthave
      objectDefinition:
        apiVersion: rbac.authorization.k8s.io/v1
        kind: ClusterRole
        metadata:
          name: ecr-credential-refresh
          labels:
            app: ecr-credential-refresh
        rules:
          - apiGroups: ["config.openshift.io"]
            resources: ["imagedigestmirrorsets", "infrastructures"]
            verbs: ["get", "list"]
    - complianceType: mustonlyhave
      metadataComplianceType: musthave
      objectDefinition:
        apiVersion: rbac.authorization.k8s.io/v1
        kind: ClusterRoleBinding
        metadata:
          name: ecr-credential-refresh
          labels:
            app: ecr-credential-refresh
        subjects:
          - kind: ServiceAccount
            name: ecr-credential-refresh
            namespace: kube-system
        roleRef:
          kind: ClusterRole
          name: ecr-credential-refresh
          apiGroup: rbac.authorization.k8s.io
    - complianceType: mustonlyhave
      metadataComplianceType: musthave
      objectDefinition:
        apiVersion: v1
        kind: ConfigMap
        metadata:
          name: ecr-credential-refresh-script
          namespace: kube-system
          labels:
            app: ecr-credential-refresh
        data:
          refresh.sh: |
            #!/bin/bash
            #
            # ECR Credential Refresh Script for Zero-Egress HCP Clusters
            #
            # Gets ECR authorization token using the node's ECR credential helper
            # and updates additional-pull-secret in kube-system namespace. HCCO then
            # merges this with original credentials to create global-pull-secret.
            #
            # This script auto-detects zero-egress clusters by checking for IDMS.
            # Non-zero-egress clusters exit early with success (no-op).
            #
            # SOP: https://github.com/openshift/ops-sop/blob/master/hypershift/knowledge_base/howto/zero-egress-ecr-credential-refresh.md
            # Tracking: OHSS-49424
            #
            set -euo pipefail

            SECRET_NAME="${SECRET_NAME:-additional-pull-secret}"
            NAMESPACE="${NAMESPACE:-kube-system}"
            HELPER_PATH="${HELPER_PATH:-/host/usr/libexec/kubelet-image-credential-provider-plugins/ecr-credential-provider}"

            log() {
                echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"
            }

            # Check if this is a zero-egress cluster by detecting IDMS with ECR mirrors
            is_zero_egress_cluster() {
                log "Checking if cluster is zero-egress..."
                local mirror
                mirror=$(oc get imagedigestmirrorset -o jsonpath='{.items[0].spec.imageDigestMirrors[0].mirrors[0]}' 2>/dev/null || true)
                if [[ -n "$mirror" && "$mirror" =~ ^[0-9]+\.dkr\.ecr\.[a-z0-9-]+\.amazonaws\.com ]]; then
                    log "Zero-egress cluster detected (IDMS mirror: $mirror)"
                    return 0
                fi
                log "Not a zero-egress cluster (no ECR IDMS found)"
                return 1
            }

            # Discover ECR registry from ImageDigestMirrorSet or environment
            discover_ecr_registry() {
                log "Discovering ECR registry from cluster configuration..."

                # Check environment variables first
                if [[ -n "${AWS_ACCOUNT_ID:-}" && -n "${AWS_REGION:-}" ]]; then
                    ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
                    log "Using ECR registry from environment: $ECR_REGISTRY"
                    return 0
                fi

                # Extract from ImageDigestMirrorSet
                local mirror
                mirror=$(oc get imagedigestmirrorset -o jsonpath='{.items[0].spec.imageDigestMirrors[0].mirrors[0]}' 2>/dev/null || true)
                if [[ "$mirror" =~ ^([0-9]+)\.dkr\.ecr\.([a-z0-9-]+)\.amazonaws\.com ]]; then
                    AWS_ACCOUNT_ID="${BASH_REMATCH[1]}"
                    AWS_REGION="${BASH_REMATCH[2]}"
                    # ECR registry is just the host, not including any path
                    ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
                    log "Discovered ECR registry: $ECR_REGISTRY"
                    return 0
                fi

                log "ERROR - Could not discover ECR registry"
                return 1
            }

            # Get ECR token using the credential helper
            get_ecr_token() {
                log "Getting ECR authorization token via credential helper..."

                if [[ ! -x "$HELPER_PATH" ]]; then
                    log "ERROR - ECR credential helper not found or not executable: $HELPER_PATH"
                    return 1
                fi

                # The helper expects a CredentialProviderRequest JSON with kind, apiVersion, and image
                local request='{"kind":"CredentialProviderRequest","apiVersion":"credentialprovider.kubelet.k8s.io/v1","image":"'"${ECR_REGISTRY}"'/test"}'
                local response

                if ! response=$(echo "$request" | "$HELPER_PATH" get-credentials 2>&1); then
                    log "ERROR - Failed to get credentials from helper: $response"
                    return 1
                fi

                # Extract password from CredentialProviderResponse using grep/sed (jq not available in CLI image)
                # Response format: {"kind":"CredentialProviderResponse",...,"auth":{"registry":{"username":"AWS","password":"..."}}}
                # The password is a base64-encoded string, so we extract between "password":" and the next "
                ECR_PASSWORD=$(echo "$response" | grep -o '"password":"[^"]*"' | head -1 | sed 's/"password":"//;s/"$//')
                if [[ -z "$ECR_PASSWORD" ]]; then
                    log "ERROR - No password in credential helper response"
                    log "Response: $response"
                    return 1
                fi

                log "Successfully retrieved ECR authorization token"
                return 0
            }

            # Update additional-pull-secret with ECR credentials
            update_secret() {
                log "Updating $SECRET_NAME in $NAMESPACE..."

                local auth_token
                auth_token=$(echo -n "AWS:${ECR_PASSWORD}" | base64 -w0)

                local config_json
                config_json=$(cat <<EOF
            {
              "auths": {
                "$ECR_REGISTRY": {
                  "auth": "$auth_token",
                  "email": ""
                }
              }
            }
            EOF
            )

                local config_b64
                config_b64=$(echo -n "$config_json" | base64 -w0)

                # Check if secret exists
                if oc get secret "$SECRET_NAME" -n "$NAMESPACE" &>/dev/null; then
                    # Patch existing secret
                    if ! oc patch secret "$SECRET_NAME" -n "$NAMESPACE" \
                        --type=merge -p '{"data":{".dockerconfigjson":"'"$config_b64"'"}}'; then
                        log "ERROR - Failed to patch secret"
                        return 1
                    fi
                    log "Successfully patched $SECRET_NAME with credentials for $ECR_REGISTRY"
                else
                    # Create new secret
                    cat <<EOF | oc apply -f -
            apiVersion: v1
            kind: Secret
            metadata:
              name: $SECRET_NAME
              namespace: $NAMESPACE
            type: kubernetes.io/dockerconfigjson
            data:
              .dockerconfigjson: $config_b64
            EOF
                    if [[ $? -ne 0 ]]; then
                        log "ERROR - Failed to create secret"
                        return 1
                    fi
                    log "Successfully created $SECRET_NAME with credentials for $ECR_REGISTRY"
                fi
                return 0
            }

            main() {
                # Step 0: Check if this is a zero-egress cluster
                if ! is_zero_egress_cluster; then
                    log "Skipping - not a zero-egress cluster"
                    exit 0
                fi

                # Step 1: Discover ECR registry
                if ! discover_ecr_registry; then
                    log "FATAL - Could not determine ECR registry"
                    exit 1
                fi

                log "Starting ECR credential refresh for $ECR_REGISTRY"

                # Step 2: Get ECR token using credential helper
                if ! get_ecr_token; then
                    log "FATAL - Could not get ECR token"
                    exit 1
                fi

                # Step 3: Update the secret
                if ! update_secret; then
                    log "FATAL - Could not update secret"
                    exit 1
                fi

                log "ECR credential refresh completed successfully"
            }

            main "$@"
    - complianceType: mustonlyhave
      metadataComplianceType: musthave
      objectDefinition:
        apiVersion: batch/v1
        kind: CronJob
        metadata:
          name: ecr-credential-refresh
          namespace: kube-system
          labels:
            app: ecr-credential-refresh
        spec:
          schedule: "0 */4 * * *"
          concurrencyPolicy: Forbid
          successfulJobsHistoryLimit: 3
          failedJobsHistoryLimit: 3
          jobTemplate:
            spec:
              backoffLimit: 3
              activeDeadlineSeconds: 300
              template:
                metadata:
                  labels:
                    app: ecr-credential-refresh
                spec:
                  serviceAccountName: ecr-credential-refresh
                  restartPolicy: OnFailure
                  nodeSelector:
                    node-role.kubernetes.io/worker: ""
                  tolerations:
                    - operator: Exists
                  hostNetwork: true
                  dnsPolicy: ClusterFirstWithHostNet
                  containers:
                    - name: refresh
                      # Dynamic lookup: get image from node-resolver DaemonSet
                      # This image is guaranteed to be cached on worker nodes
                      # Uses index function since ACM templates don't support bracket notation
                      image: '{{ (index (lookup "apps/v1" "DaemonSet" "openshift-dns" "node-resolver").spec.template.spec.containers 0).image }}'
                      imagePullPolicy: IfNotPresent
                      command:
                        - /bin/bash
                        - /scripts/refresh.sh
                      volumeMounts:
                        - name: script
                          mountPath: /scripts
                          readOnly: true
                        - name: host-root
                          mountPath: /host
                          readOnly: true
                      resources:
                        requests:
                          cpu: 10m
                          memory: 64Mi
                        limits:
                          cpu: 100m
                          memory: 128Mi
                      securityContext:
                        allowPrivilegeEscalation: false
                        capabilities:
                          drop:
                            - ALL
                        seccompProfile:
                          type: RuntimeDefault
                  volumes:
                    - name: script
                      configMap:
                        name: ecr-credential-refresh-script
                        defaultMode: 0755
                    - name: host-root
                      hostPath:
                        path: /
                        type: Directory
    - complianceType: mustonlyhave
      metadataComplianceType: musthave
      objectDefinition:
        apiVersion: batch/v1
        kind: Job
        metadata:
          name: ecr-credential-refresh-initial
          namespace: kube-system
          labels:
            app: ecr-credential-refresh
            app.kubernetes.io/component: initial-refresh
        spec:
          backoffLimit: 3
          activeDeadlineSeconds: 300
          template:
            metadata:
              labels:
                app: ecr-credential-refresh
            spec:
              serviceAccountName: ecr-credential-refresh
              restartPolicy: OnFailure
              nodeSelector:
                node-role.kubernetes.io/worker: ""
              tolerations:
                - operator: Exists
              hostNetwork: true
              dnsPolicy: ClusterFirstWithHostNet
              containers:
                - name: refresh
                  # Dynamic lookup: get image from node-resolver DaemonSet
                  # This image is guaranteed to be cached on worker nodes
                  # Uses index function since ACM templates don't support bracket notation
                  image: '{{ (index (lookup "apps/v1" "DaemonSet" "openshift-dns" "node-resolver").spec.template.spec.containers 0).image }}'
                  imagePullPolicy: IfNotPresent
                  command:
                    - /bin/bash
                    - /scripts/refresh.sh
                  volumeMounts:
                    - name: script
                      mountPath: /scripts
                      readOnly: true
                    - name: host-root
                      mountPath: /host
                      readOnly: true
                  resources:
                    requests:
                      cpu: 10m
                      memory: 64Mi
                    limits:
                      cpu: 100m
                      memory: 128Mi
                  securityContext:
                    allowPrivilegeEscalation: false
                    capabilities:
                      drop:
                        - ALL
                    seccompProfile:
                      type: RuntimeDefault
              volumes:
                - name: script
                  configMap:
                    name: ecr-credential-refresh-script
                    defaultMode: 0755
                - name: host-root
                  hostPath:
                    path: /
                    type: Directory
  pruneObjectBehavior: DeleteIfCreated
  remediationAction: enforce
  severity: low
